/*
 * Copyright (c) 2024 Snowflake Computing Inc. All rights reserved.
 */

package net.snowflake.ingest.streaming.internal;

import static net.snowflake.ingest.utils.Constants.BLOB_EXTENSION_TYPE;

import com.google.common.annotations.VisibleForTesting;
import java.io.IOException;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import net.snowflake.client.jdbc.SnowflakeSQLException;
import net.snowflake.ingest.connection.IngestResponseException;
import net.snowflake.ingest.utils.ErrorCode;
import net.snowflake.ingest.utils.SFException;
import net.snowflake.ingest.utils.Utils;

/** Class to manage single Snowflake internal stage */
class InternalStageManager<T> implements StorageManager<T> {
  // Target stage for the client
  private final StreamingIngestStorage<T> targetStage;

  // Increasing counter to generate a unique blob name per client
  private final AtomicLong counter;

  // Whether the manager in test mode
  private final boolean isTestMode;

  // Snowflake service client used for configure calls
  private final SnowflakeServiceClient snowflakeServiceClient;

  // Client prefix generated by the Snowflake server
  private final String clientPrefix;

  /**
   * Constructor for InternalStageManager
   *
   * @param isTestMode whether the manager in test mode
   * @param role the role of the client
   * @param clientName the name of the client
   * @param snowflakeServiceClient the Snowflake service client to use for configure calls
   */
  InternalStageManager(
      boolean isTestMode,
      String role,
      String clientName,
      SnowflakeServiceClient snowflakeServiceClient) {
    this.snowflakeServiceClient = snowflakeServiceClient;
    this.isTestMode = isTestMode;
    this.counter = new AtomicLong(0);
    try {
      if (!isTestMode) {
        ClientConfigureRequest request = new ClientConfigureRequest(role);
        ConfigureResponse response = this.snowflakeServiceClient.clientConfigure(request);
        this.clientPrefix = response.getClientPrefix();
        this.targetStage =
            new StreamingIngestStorage<>(
                this, clientName, response.getStageLocation(), request, DEFAULT_MAX_UPLOAD_RETRIES);
      } else {
        this.clientPrefix = "testPrefix";
        this.targetStage =
            new StreamingIngestStorage<>(
                this,
                "testClient",
                (StreamingIngestStorage.SnowflakeFileTransferMetadataWithAge) null,
                new ClientConfigureRequest(role),
                DEFAULT_MAX_UPLOAD_RETRIES);
      }
    } catch (IngestResponseException | IOException e) {
      throw new SFException(e, ErrorCode.CLIENT_CONFIGURE_FAILURE, e.getMessage());
    } catch (SnowflakeSQLException e) {
      throw new SFException(e, ErrorCode.UNABLE_TO_CONNECT_TO_STORAGE, e.getMessage());
    }
  }

  /**
   * Get the storage. In this case, the storage is always the target stage as there's only one stage
   * in non-iceberg mode.
   *
   * @param channelFlushContext this parameter does not affect the method outcome
   * @return the target storage
   */
  @Override
  @SuppressWarnings("unused")
  public StreamingIngestStorage<T> getStorage(ChannelFlushContext channelFlushContext) {
    // There's always only one stage for the client in non-iceberg mode
    return targetStage;
  }

  /**
   * Add storage to the manager. Do nothing as there's only one stage in non-Iceberg mode.
   *
   * @param dbName
   * @param schemaName
   * @param tableName
   * @param fileLocationInfo
   */
  @Override
  public void addStorage(
      String dbName, String schemaName, String tableName, FileLocationInfo fileLocationInfo) {}

  /**
   * Configure method for storage
   *
   * @param request the configure request
   * @return the configure response
   */
  @Override
  public ConfigureResponse configure(ConfigureRequest request) {
    try {
      return snowflakeServiceClient.clientConfigure((ClientConfigureRequest) request);
    } catch (IngestResponseException | IOException e) {
      throw new SFException(e, ErrorCode.CLIENT_CONFIGURE_FAILURE, e.getMessage());
    }
  }

  /**
   * Generate a blob path, which is: "YEAR/MONTH/DAY_OF_MONTH/HOUR_OF_DAY/MINUTE/<current utc
   * timestamp + client unique prefix + thread id + counter>.BDEC"
   *
   * @return the generated blob file path
   */
  @Override
  public String generateBlobPath() {
    Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    return getBlobPath(calendar, this.clientPrefix);
  }

  @Override
  public void decrementBlobSequencer() {
    this.counter.decrementAndGet();
  }

  /** For TESTING */
  @VisibleForTesting
  public String getBlobPath(Calendar calendar, String clientPrefix) {
    if (this.isTestMode && clientPrefix == null) {
      clientPrefix = "testPrefix";
    }

    Utils.assertStringNotNullOrEmpty("client prefix", clientPrefix);
    int year = calendar.get(Calendar.YEAR);
    int month = calendar.get(Calendar.MONTH) + 1; // Gregorian calendar starts from 0
    int day = calendar.get(Calendar.DAY_OF_MONTH);
    int hour = calendar.get(Calendar.HOUR_OF_DAY);
    int minute = calendar.get(Calendar.MINUTE);
    long time = TimeUnit.MILLISECONDS.toSeconds(calendar.getTimeInMillis());
    long threadId = Thread.currentThread().getId();
    // Create the blob short name, the clientPrefix contains the deployment id
    String blobShortName =
        Long.toString(time, 36)
            + "_"
            + clientPrefix
            + "_"
            + threadId
            + "_"
            + this.counter.getAndIncrement()
            + "."
            + BLOB_EXTENSION_TYPE;
    return year + "/" + month + "/" + day + "/" + hour + "/" + minute + "/" + blobShortName;
  }

  /**
   * Get the unique client prefix generated by the Snowflake server
   *
   * @return the client prefix
   */
  @Override
  public String getClientPrefix() {
    return this.clientPrefix;
  }
}
