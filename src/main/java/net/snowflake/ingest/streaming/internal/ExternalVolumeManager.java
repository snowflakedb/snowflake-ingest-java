/*
 * Copyright (c) 2024 Snowflake Computing Inc. All rights reserved.
 */

package net.snowflake.ingest.streaming.internal;

import java.io.IOException;
import java.util.Calendar;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import net.snowflake.client.jdbc.SnowflakeSQLException;
import net.snowflake.ingest.utils.ErrorCode;
import net.snowflake.ingest.utils.SFException;

/** Class to manage multiple external volumes */
class ExternalVolumeManager<T> implements StorageManager<T> {

  // Reference to the external volume per table
  private final Map<String, StreamingIngestStorage<T>> externalVolumeMap;

  // Reference to the owning client
  private final SnowflakeStreamingIngestClientInternal<T> owningClient;

  // Reference to the Snowflake service client used for configure calls
  private final SnowflakeServiceClient snowflakeServiceClient;

  // Client prefix generated by the Snowflake server
  private final String clientPrefix;

  /**
   * Constructor for ExternalVolumeManager
   *
   * @param isTestMode whether the manager in test mode
   * @param client the owning client
   * @param snowflakeServiceClient the Snowflake service client used for configure calls
   */
  ExternalVolumeManager(
      boolean isTestMode,
      SnowflakeStreamingIngestClientInternal<T> client,
      SnowflakeServiceClient snowflakeServiceClient) {
    this.owningClient = client;
    this.snowflakeServiceClient = snowflakeServiceClient;
    this.externalVolumeMap = new ConcurrentHashMap<>();
    this.clientPrefix =
        isTestMode
            ? "testPrefix"
            : this.snowflakeServiceClient
                .clientConfigure(new ConfigureRequest(client.getRole()))
                .getClientPrefix();
  }

  /**
   * Given a channel context, return the target storage by looking up the table name
   *
   * @param channelFlushContext the channel flush context containing the table name
   * @return target storage
   */
  @Override
  public StreamingIngestStorage<T> getStorage(ChannelFlushContext channelFlushContext) {
    // Only one chunk per blob in Iceberg mode.
    StreamingIngestStorage<T> stage =
        this.externalVolumeMap.get(channelFlushContext.getFullyQualifiedTableName());

    if (stage == null) {
      throw new SFException(
          ErrorCode.INTERNAL_ERROR,
          String.format(
              "No storage found for table %s", channelFlushContext.getFullyQualifiedTableName()));
    }

    return stage;
  }

  /**
   * Add a storage to the manager by looking up the table name from the open channel response
   *
   * @param dbName the database name
   * @param schemaName the schema name
   * @param tableName the table name
   * @param fileLocationInfo response from open channel
   */
  @Override
  public void addStorage(
      String dbName, String schemaName, String tableName, FileLocationInfo fileLocationInfo) {
    String fullyQualifiedTableName = String.format("%s.%s.%s", dbName, schemaName, tableName);

    try {
      this.externalVolumeMap.putIfAbsent(
          fullyQualifiedTableName,
          new StreamingIngestStorage<>(
              this,
              this.owningClient.getName(),
              fileLocationInfo,
              new ConfigureRequest(this.owningClient.getRole(), dbName, schemaName, tableName),
              DEFAULT_MAX_UPLOAD_RETRIES));
    } catch (SnowflakeSQLException | IOException err) {
      throw new SFException(err, ErrorCode.UNABLE_TO_CONNECT_TO_STAGE);
    }
  }

  /**
   * Configure method for storage
   *
   * @param request the configure request
   * @return the configure response
   */
  @Override
  public ConfigureResponse configure(ConfigureRequest request) {
    return this.snowflakeServiceClient.channelConfigure(request);
  }

  // TODO: SNOW-1502887 Blob path generation for iceberg table
  @Override
  public String generateBlobPath() {
    return "snow_dummy_file_name";
  }

  // TODO: SNOW-1502887 Blob path generation for iceberg table
  @Override
  public void decrementBlobSequencer() {}

  // TODO: SNOW-1502887 Blob path generation for iceberg table
  public String getBlobPath(Calendar calendar, String clientPrefix) {
    return "";
  }

  /**
   * Get the client prefix from first external volume in the map
   *
   * @return the client prefix
   */
  @Override
  public String getClientPrefix() {
    return this.clientPrefix;
  }
}
