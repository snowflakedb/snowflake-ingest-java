/*
 * Copyright (c) 2024 Snowflake Computing Inc. All rights reserved.
 */

package net.snowflake.ingest.streaming.internal;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import net.snowflake.client.jdbc.internal.apache.http.client.utils.URIBuilder;
import net.snowflake.ingest.connection.IngestResponseException;
import net.snowflake.ingest.utils.ErrorCode;
import net.snowflake.ingest.utils.SFException;

/** Class to manage multiple external volumes */
class ExternalVolumeManager implements IStorageManager {
    // Reference to the external volume per table
    private final Map<String, ExternalVolume> externalVolumeMap;

    // name of the owning client
    private final String clientName;

    // Reference to the Snowflake service client used for configure calls
    private final SnowflakeServiceClient serviceClient;

    // Client prefix generated by the Snowflake server
    private final String clientPrefix;

    private final Object registerTableLock = new Object();

    /**
     * Constructor for ExternalVolumeManager
     *
     * @param isTestMode whether the manager in test mode
     * @param role the role of the client
     * @param clientName the name of the client
     * @param snowflakeServiceClient the Snowflake service client used for configure calls
     */
    ExternalVolumeManager(
            boolean isTestMode,
            String role,
            String clientName,
            SnowflakeServiceClient snowflakeServiceClient) {
        this.clientName = clientName;
        this.serviceClient = snowflakeServiceClient;
        this.externalVolumeMap = new ConcurrentHashMap<>();
        try {
            this.clientPrefix =
                    isTestMode
                            ? "testPrefix"
                            : this.serviceClient
                            .clientConfigure(new ClientConfigureRequest(role))
                            .getClientPrefix();
        } catch (IngestResponseException | IOException e) {
            throw new SFException(e, ErrorCode.CLIENT_CONFIGURE_FAILURE, e.getMessage());
        }
    }

    /**
     * Given a fully qualified table name, return the target storage by looking up the table name
     *
     * @param fullyQualifiedTableName the target fully qualified table name
     * @return target storage
     */
    @Override
    public IStorage getStorage(String fullyQualifiedTableName) {
        // Only one chunk per blob in Iceberg mode.
        return getVolumeSafe(fullyQualifiedTableName);
    }

    /**
     * Informs the storage manager about a new table that's being ingested into by the client.
     */
    @Override
    public void registerTable(TableRef tableRef) {
        if (this.externalVolumeMap.containsKey(tableRef.fullyQualifiedName)) {
            return;
        }

        // future enhancement - per table locks instead of per-client lock
        synchronized (registerTableLock) {
            if (this.externalVolumeMap.containsKey(tableRef.fullyQualifiedName)) {
                return;
            }

            try {
                // TODO: Does the client prefix need to be dynamically updated with repeated calls to client_configure? If yes, why?
                ExternalVolume externalVolume = new ExternalVolume(clientName, getClientPrefix(), tableRef, serviceClient);
                this.externalVolumeMap.put(tableRef.fullyQualifiedName, externalVolume);
            } catch (Exception err) {
                throw new SFException(
                        err,
                        ErrorCode.UNABLE_TO_CONNECT_TO_STAGE,
                        String.format("fullyQualifiedTableName=%s", tableRef.fullyQualifiedName));
            }
        }
    }

    @Override
    public BlobPath generateBlobPath(String fullyQualifiedTableName) {
        ExternalVolume volume = getVolumeSafe(fullyQualifiedTableName);
        String url = volume.dequeueUrl();
        try {
            return new BlobPath(url, true, new URIBuilder(url).removeQuery().build().toString());
        } catch (URISyntaxException e) {
            throw new SFException(
                    ErrorCode.INTERNAL_ERROR,
                    String.format("Presigned URLs returned by the server cannot be parsed by URI Builder. " +
                            "TableRef=%s",
                            fullyQualifiedTableName));
        }
    }

    /**
     * Get the client prefix from first external volume in the map
     *
     * @return the client prefix
     */
    @Override
    public String getClientPrefix() {
        return this.clientPrefix;
    }

    private ExternalVolume getVolumeSafe(String fullyQualifiedTableName) {
        ExternalVolume volume = this.externalVolumeMap.get(fullyQualifiedTableName);

        if (volume == null) {
            throw new SFException(
                    ErrorCode.INTERNAL_ERROR,
                    String.format("No external volume found for table %s", fullyQualifiedTableName));
        }

        return volume;
    }
}
